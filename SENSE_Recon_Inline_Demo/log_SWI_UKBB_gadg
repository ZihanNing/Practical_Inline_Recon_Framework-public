===============================Lucilio reconInvert(refscan)======================
size(rec.TWD.S)

ans =

   288    58    64    46     1     1     1     2

---------Acquired grid sizes
NImageCols =

   288 (ok)
K>> rec.Enc.(t).AcqN

ans =

   576    64    46 (ok)

---------number of coils
K>> rec.Enc.(t).CoilN

ans =

    58 (ok)

---------OS factors
K>> ~isempty(TW.hdr.Meas.flPhaseOS)

ans =

  logical

   0

K>> ~isempty(TW.hdr.Meas.flSliceOS)

ans =

  logical

   1
K>> rec.Enc.(t).Overs(3)

ans =

    1.0833 (ok)

---------Accel factors
K>> rec.Enc.(t).RegridMode

ans =

     1 (ok)

K>> rec.Enc.(t).Accel

ans =

     1     1     1 (ok)


---------Partial fourier
refscan skipped


---------recon & output grid size 
K>> rec.Enc.(t).RecN

ans =

   288    64    46 (ok)

K>> rec.Enc.(t).OutN

ans =

   288    64    42 (ok)

---------slice separation
refscan skipped (ok)


---------FOV and voxel size
K>> rec.Enc.(t).AcqFOV

ans =

  230.0000  204.4444  144.0000 (ok)

K>> rec.Enc.(t).AcqFOV

ans =

  230.0000  204.4444  156.0000 (ok)

K>> rec.Enc.(t).AcqDelta

ans =

    0.7986    3.1944    3.3913 (ok)
K>> NX

NX =

   288    58    64    46     1     1     1     2 (ok)
iSlicePositionsMin =

     1 (ok)


---------regriding 
refscan skipped (ok)


---------geometry (not aligned at all) -> should be rehandling
K>> rec.Geom.(t).MT

ans =

    0.0193   -3.1884    0.1916   96.0919
   -0.7704   -0.1219   -0.8838  123.1260
   -0.2095    0.1540    3.2685  -81.0562
         0         0         0    1.0000


---------noise
refscan temporarliy skipped (ok)

---------invert phase (not sure)
rec.P.echoOrder=TW.(field).Seg(TW.(field).Sli==1 & TW.(field).Rep==1);
rec.P.corrLine=TW.(field).Lin(TW.(field).Sli==1 & TW.(field).Rep==1);


---------invert readout
normal

---------nyquist correction
refscan skipped


---------generate mask & multiband
refscan skipped

---------invert (fft) & permute
normal


====================all parameters includes 'field' which is important for ref
1. geometry
slicePos=TW.(field).slicePos(:,iSlicePositionsMin);
2. invert phase
rec.P.echoOrder=TW.(field).Seg(TW.(field).Sli==1 & TW.(field).Rep==1);
rec.P.corrLine=TW.(field).Lin(TW.(field).Sli==1 & TW.(field).Rep==1);

====================saved files related to ref
rec_after_Invert_S



===============================DISORDER gadg(Geometry)======================
some of the parameters might need to be permuted as [Lin RO Par] first and converted back to get this geom correct

idxToUse =

    34     7 (ok)

K>> rec.Enc.AcqVoxelSize

ans =

    0.7986    0.7986    3.0000 (ok)

K>> rec.Par.Mine.Asca (ok)

ans =

    0.7986         0         0         0
         0    0.7986         0         0
         0         0    3.0000         0
         0         0         0    1.0000

K>> rec.Par.Mine.Arot (ok)

ans =

    0.9981   -0.0242   -0.0565         0
    0.0382    0.9647    0.2606         0
    0.0482   -0.2623    0.9638         0
         0         0         0    1.0000


K>> rec.Par.Mine.Atra (ok)

ans =

    1.0000         0         0   -2.0217
         0    1.0000         0   15.5768
         0         0    1.0000  -18.0412
         0         0         0    1.0000

N =

   256   288    52 (ok)

orig = (ok)

  129.0000
  145.0000
   26.5000

K>> rec.Par.Mine.Atra (ok)

ans =

    1.0000         0         0  -97.5512
         0    1.0000         0 -120.7825
         0         0    1.0000  -69.2569
         0         0         0    1.0000

K>> rec.Par.Mine.MTT (ok)

ans =

     1     0     0     0
     0     1     0     0
     0     0     1     0
     0     0     0     1

K>> rec.Par.Mine.APhiRec (ok)

ans =

    0.7971   -0.0193   -0.1695  -97.5512
    0.0305    0.7704    0.7818 -120.7825
    0.0385   -0.2095    2.8914  -69.2569
         0         0         0    1.0000

K>> rec.Par.Mine.patientPosition (ok)

ans =

    'HFS'

K>> rec.Par.Mine.PCS2RAS (ok)

ans =

    -1     0     0     0
     0    -1     0     0
     0     0     1     0
     0     0     0     1

K>> rec.Par.Mine.APhiRec (ok)

ans =

   -0.7971    0.0193    0.1695   97.5512
   -0.0305   -0.7704   -0.7818  120.7825
    0.0385   -0.2095    2.8914  -69.2569
         0         0         0    1.0000

after translate -> though I#m not sure why we need translate
K>> rec.Par.Mine.APhiRec (ok)

ans =

   -0.7971    0.0193    0.1695   96.9430
   -0.0305   -0.7704   -0.7818  119.1998
    0.0385   -0.2095    2.8914  -66.5365
         0         0         0    1.0000

calculate for ACS (this might be wrong)
YSize =

   256   288    52 (ok)


ACSSize =

   256   288    52


K>> rec.Par.Mine.APhiACS

ans =

   -0.7971    0.0193    0.1695   96.9430
   -0.0305   -0.7704   -0.7818  119.1998
    0.0385   -0.2095    2.8914  -66.5365
         0         0         0    1.0000

after correction of the matrixSize of ACS
K>> ACSSize = [64 288 46]

ACSSize =

    64   288    46

K>> [rec.Enc.UnderSampling.ACSVoxelSize, rec.Par.Mine.APhiACS] = mapNIIGeom([], rec.Par.Mine.APhiRec,'resampling',[],YSize,ACSSize);%TO CHECK:AD HOC - REVERSE ENGINEERED
K>> rec.Enc.UnderSampling.ACSVoxelSize

ans =

    3.1944    0.7986    3.3913 (ok)

K>> rec.Par.Mine.APhiACS (ok)

ans =

   -3.1884    0.0193    0.1916   96.9430
   -0.1219   -0.7704   -0.8838  119.1998
    0.1540   -0.2095    3.2685  -66.5365
         0         0         0    1.0000

after permute to [RO Lin Par]
K>> rec.Enc.AcqVoxelSize

ans =

    0.7986    0.7986    3.0000

K>> rec.Par.Mine.APhiRec

ans =

    0.0193   -0.7971    0.1695   96.9430
   -0.7704   -0.0305   -0.7818  119.1998
   -0.2095    0.0385    2.8914  -66.5365
         0         0         0    1.0000

K>> rec.Enc.UnderSampling.ACSVoxelSize

ans =

    0.7986    3.1944    3.3913

K>> rec.Par.Mine.APhiACS

ans =

    0.0193   -3.1884    0.1916   96.9430
   -0.7704   -0.1219   -0.8838  119.1998
   -0.2095    0.1540    3.2685  -66.5365
         0         0         0    1.0000






===============================Lucilio reconInvert(highres)======================

K>> size(rec.TWD.x)

ans =

   288    58   222    46     1     1     1     2


---------Acquired grid sizes
K>> NImageCols

NImageCols =

   288 (ok)

K>> rec.Enc.(t).AcqN

ans =

   576   222    46 -> this stage has been skipped since zero-padding has been taken care of by pre-gadget (ok)
   
---------number of coils
K>> rec.Enc.(t).CoilN

ans =

    58 (ok)
    
---------OS factors
K>> rec.Enc.(t).Overs

ans =

    1.0000    1.0000    1.0833 (ok)

---------Accel factors
K>> rec.Enc.(t).RegridMode

ans =

     1 (ok)
     
K>> rec.Enc.(t).Accel (this seems to only related to phase/slice resolution)

ans =

     1     1     1 (ok)

K>> rec.Enc.(t).AcqN

ans =

   288   222    46 (ok) -> this step is skipped, the gadgetron data is already padded, so directly give the value after zero-padding


---------Partial fourier (calc PF and zero-padding and shift) -> probably already padded (assume it padded corretly)
high-res skipped 
K>> rec.Enc.(t).AcqNNoPF

ans =

   288   222    46 (skipped)

K>> rec.Enc.(t).ThreeD

ans =

     1 (ok)

K>> rec.Enc.(t).AcqN

ans =

   288   256    52 (ok)

K>> pad

pad =

     0    34     6 (skipped)

K>> rec.Enc.(t).APF

ans =

  1×3 cell array

    {0×0 double}    {0×0 double}    {0×0 double}

K>> pad -> all post pad here

pad =

     0     0    34     6

K>> rec.Enc.(t).APF

ans =

  1×3 cell array

    {288×1 gpuArray}    {256×1 gpuArray}    {52×1 gpuArray}

K>> cshift

cshift =

     0     0     0     0

K>> cshift -> prepad [33 6] post pad [1 0]

cshift =

     0     0    33     6

K>> size(rec.TWD.x)

ans =

   288    58   256    52     1     1     1     2 (ok)

---------recon & output grid size 
K>> rec.Enc.(t).RecN

ans =

   288   256    52 (ok)

Reconstructed size: 288 256 52
K>> rec.Enc.(t).OutN

ans =

   288   256    48 (ok)

---------slice separation (ok)
refscan skipped 
high-res also skipped


---------FOV and voxel size
K>> rec.Enc.(t).AcqFOV

ans =

  230.0000  204.4444  144.0000

K>> rec.Enc.(t).AcqFOV

ans =

  230.0000  204.4444  156.0000 (ok)

K>> rec.Enc.(t).AcqDelta

ans =

    0.7986    0.7986    3.0000 (ok)
K>> NX

NX =

   288    58   256    52     1     1     1     2 (ok)
iSlicePositionsMin =

     1 (ok)


---------regriding (ok)
refscan skipped 
high-res also skipped


---------geometry (not aligned at all) -> should be rehandling
K>> rec.Geom.(t).MT

ans =

    0.0193   -0.7971    0.1695   96.8584
   -0.7704   -0.0305   -0.7818  119.5907
   -0.2095    0.0385    2.8914  -67.9822
         0         0         0    1.0000


after rehandling
K>> rec.Enc.(t).AcqN

ans =

   288   256    52

K>> rec.Enc.(t).AcqDelta

ans =

    0.7986    0.7986    3.0000

K>> rec.Geom.(t).MT

ans =

    0.0193   -0.7971    0.1695   96.9430
   -0.7704   -0.0305   -0.7818  119.1998
   -0.2095    0.0385    2.8914  -66.5365
         0         0         0    1.0000

K>> rec.Enc.S.AcqDelta

ans =

    0.7986    3.1944    3.3913

K>> rec.Enc.S.AcqN

ans =

   288    64    46

K>> rec.Geom.S.MT

ans =

    0.0193   -3.1884    0.1916   96.9430
   -0.7704   -0.1219   -0.8838  119.1998
   -0.2095    0.1540    3.2685  -66.5365
         0         0         0    1.0000

---------noise
refscan temporarliy skipped 
high-res temporarliy skipped

---------invert phase (not sure)
previous temporarily skipped
since the nyquist correction and generation of mask are all skipped for both refscan & highres, the following part will be not important then
rec.P.echoOrder=TW.(field).Seg(TW.(field).Sli==1 & TW.(field).Rep==1);
rec.P.corrLine=TW.(field).Lin(TW.(field).Sli==1 & TW.(field).Rep==1);


---------invert readout
normal

---------nyquist correction
refscan skipped
high-res also skipped


---------generate mask & multiband
refscan skipped
high-res also skipped

---------invert (fft) & permute
normal


====================all parameters includes 'field' which is important for ref
1. geometry
slicePos=TW.(field).slicePos(:,iSlicePositionsMin);
2. invert phase (will not be used, don't need to worry)
rec.P.echoOrder=TW.(field).Seg(TW.(field).Sli==1 & TW.(field).Rep==1);
rec.P.corrLine=TW.(field).Lin(TW.(field).Sli==1 & TW.(field).Rep==1);

====================saved files related to ref
rec_after_Invert_S


===============================Lucilio Coil Sens Estimation======================
size(rec.xS)

ans =

   288    64    46    58     1     1     1     2

size(rec.S)
ans =

   288    64    46    58     1     1     1     2


took the first echo
K>> size(rec.S)

ans =

   288    64    46    58

K>> size(S)

ans =

   288    64    46    58











































